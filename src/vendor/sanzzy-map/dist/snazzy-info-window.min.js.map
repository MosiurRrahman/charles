{"version":3,"sources":["snazzy-info-window.js"],"names":["copyKeys","target","source","Object","keys","forEach","key","mergeDefaultOptions","opts","copy","_defaultOptions","obj","_typeof","objCopy","parseAttribute","attribute","defaultValue","re","test","match","exec","value","units","original","setHTML","container","content","firstChild","removeChild","innerHTML","appendChild","oppositePlacement","p","capitalizePlacement","charAt","toUpperCase","slice","toLatLng","v","undefined","google","maps","LatLng","lat","lng","_defaultShadow","h","blur","spread","color","placement","pointer","openOnMarkerClick","closeOnMapClick","closeWhenOthersOpen","showCloseButton","panOnOpen","edgeOffset","top","right","bottom","left","SnazzyInfoWindow","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","_html","_opts","_callbacks","callbacks","_marker","marker","_map","map","_position","position","_isOpen","_listeners","trackListener","event","addListener","getMap","open","offset","String","toLowerCase","border","shadow","callback","lambda","apply","listener","persistent","push","clearPersistent","e","removeListener","filter","result","activateCallback","setMap","clearListeners","latLng","draw","resize","reposition","wrapper","style","marginLeft","marginTop","bg","backgroundColor","contentWrapper","pointerBg","padding","shadowFrame","borderRadius","fontSize","fontColor","shadowPointer","width","height","pointerBorder","borderWidth","bWidth","Math","round","offsetWidth","clientWidth","pLength","min","offsetHeight","triangleDiff","reverseP","borderColor","isSet","hOffset","vOffset","formatBoxShadow","boxShadow","hRotated","vRotated","shadowPointerInner","opacity","shadowWrapper","divPixel","getProjection","fromLatLngToDivPixel","floatWrapper","floor","y","x","trigger","_eventPrefix","_this2","applyCss","element","args","i","length","className","newElement","_len","arguments","Array","_key","document","createElement","wrapperClass","closeButtonMarkup","d","closeButton","setAttribute","getPanes","floatPane","close","other","_previousWidth","_previousHeight","getDiv","ow","oh","pw","ph","addDomListener","cancelBubble","stopPropagation","parent","parentElement","mb","getBoundingClientRect","mib","getMapInnerBounds","wb","dx","dy","panBy","maxWidth","maxHeight","OverlayView"],"mappings":"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","file":"snazzy-info-window.min.js","sourcesContent":["// Global variables\r\nconst _classPrefix = 'si-';\r\nconst _root2 = 1.41421356237;\r\nconst _inverseRoot2 = 0.7071067811865474;\r\nconst _eventPrefix = 'snazzy-info-window-';\r\nconst _defaultShadow = {\r\n    h: '0px',\r\n    v: '3px',\r\n    blur: '6px',\r\n    spread: '0px',\r\n    color: '#000'\r\n};\r\nconst _defaultOptions = {\r\n    placement: 'top',\r\n    pointer: true,\r\n    openOnMarkerClick: true,\r\n    closeOnMapClick: true,\r\n    closeWhenOthersOpen: false,\r\n    showCloseButton: true,\r\n    panOnOpen: true,\r\n    edgeOffset: {\r\n        top: 20,\r\n        right: 20,\r\n        bottom: 20,\r\n        left: 20\r\n    }\r\n};\r\n\r\n// Copy keys from the source into the target\r\nfunction copyKeys(target, source) {\r\n    if (target && source) {\r\n        Object.keys(source).forEach((key) => {\r\n            target[key] = source[key];\r\n        });\r\n    }\r\n}\r\n\r\n// We need to safely merge options from the defaults. This will make\r\n// sure settings like edgeOffset are properly assigned.\r\nfunction mergeDefaultOptions(opts) {\r\n    const copy = {};\r\n    copyKeys(copy, _defaultOptions);\r\n    copyKeys(copy, opts);\r\n    Object.keys(_defaultOptions).forEach((key) => {\r\n        const obj = _defaultOptions[key];\r\n        if (typeof obj === 'object') {\r\n            const objCopy = {};\r\n            copyKeys(objCopy, obj);\r\n            copyKeys(objCopy, copy[key]);\r\n            copy[key] = objCopy;\r\n        }\r\n    });\r\n    return copy;\r\n}\r\n\r\n// Parse a css attribute into the numeric portion and the units\r\nfunction parseAttribute(attribute, defaultValue) {\r\n    // 1em, 1.0em, 0.1em, .1em, 1.    em\r\n    const re = /^(-{0,1}\\.{0,1}\\d+(\\.\\d+)?)[\\s|\\.]*(\\w*)$/;\r\n    if (attribute && re.test(attribute)) {\r\n        const match = re.exec(attribute);\r\n        const number = match[1];\r\n        const units = match[3] || 'px';\r\n        return { value: number * 1, units, original: attribute };\r\n    }\r\n    if (defaultValue) {\r\n        return parseAttribute(defaultValue);\r\n    }\r\n    return { original: defaultValue };\r\n}\r\n\r\n// Set the html of a container. Should support both raw text and a single\r\n// DOM Element.\r\nfunction setHTML(container, content) {\r\n    if (container) {\r\n        // Clear out everything in the container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n        if (content) {\r\n            if (typeof content === 'string') {\r\n                container.innerHTML = content;\r\n            } else {\r\n                container.appendChild(content);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Get the opposite of a given placement\r\nfunction oppositePlacement(p) {\r\n    if (p === 'top') {\r\n        return 'bottom';\r\n    } else if (p === 'bottom') {\r\n        return 'top';\r\n    } else if (p === 'left') {\r\n        return 'right';\r\n    } else if (p === 'right') {\r\n        return 'left';\r\n    }\r\n    return p;\r\n}\r\n\r\n// Return the placement with the first letter capitalized\r\nfunction capitalizePlacement(p) {\r\n    return p.charAt(0).toUpperCase() + p.slice(1);\r\n}\r\n\r\n// Convert the value into a Google Map LatLng\r\nfunction toLatLng(v) {\r\n    if (v !== undefined && v !== null && google) {\r\n        if (v instanceof google.maps.LatLng) {\r\n            return v;\r\n        } else if (v.lat !== undefined && v.lng !== undefined) {\r\n            return new google.maps.LatLng(v);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport default class SnazzyInfoWindow extends google.maps.OverlayView {\r\n\r\n    constructor(opts) {\r\n        super(opts);\r\n        // Private properties\r\n        this._html = null;\r\n        this._opts = mergeDefaultOptions(opts);\r\n        this._callbacks = this._opts.callbacks || {};\r\n        this._marker = this._opts.marker;\r\n        this._map = this._opts.map;\r\n        this._position = toLatLng(this._opts.position);\r\n        this._isOpen = false;\r\n        this._listeners = [];\r\n\r\n        // This listener remains active when the info window is closed.\r\n        if (google && this._marker && this._opts.openOnMarkerClick) {\r\n            this.trackListener(google.maps.event.addListener(this._marker, 'click', () => {\r\n                if (!this.getMap()) {\r\n                    this.open();\r\n                }\r\n            }), true);\r\n        }\r\n\r\n        // When using a position the default option for the offset is 0\r\n        if (this._position && !this._opts.offset) {\r\n            this._opts.offset = {\r\n                top: '0px',\r\n                left: '0px'\r\n            };\r\n        }\r\n\r\n        // Validate the placement option\r\n        let p = opts.placement || this._opts.position;\r\n        // The position variable was renamed to placement so we must type check\r\n        if (typeof p === 'string' || p instanceof String) {\r\n            p = p.toLowerCase();\r\n        }\r\n        if (p !== 'top' && p !== 'bottom' &&\r\n            p !== 'left' && p !== 'right') {\r\n            this._opts.placement = _defaultOptions.placement;\r\n        } else {\r\n            this._opts.placement = p;\r\n        }\r\n\r\n        // Validate the position option\r\n        p = this._opts.position;\r\n        if (p !== undefined && p !== null &&\r\n            typeof p !== 'string' && !(p instanceof String)) {\r\n            this._opts.position = p;\r\n        }\r\n\r\n        // Validate the other options\r\n        if (this._opts.border === undefined || this._opts.border === true) {\r\n            this._opts.border = {};\r\n        }\r\n        if (this._opts.pointer === undefined) {\r\n            this._opts.pointer = _defaultOptions.pointer;\r\n        }\r\n        if (this._opts.shadow === undefined || this._opts.shadow === true) {\r\n            this._opts.shadow = {};\r\n        }\r\n    }\r\n\r\n    // Activate the specified callback and return the result\r\n    activateCallback(callback) {\r\n        const lambda = this._callbacks[callback];\r\n        return lambda ? lambda.apply(this) : undefined;\r\n    }\r\n\r\n    // Track the provided listener. A persistent listener means it remains\r\n    // tracked even if the info window is closed.\r\n    trackListener(listener, persistent) {\r\n        this._listeners.push({ listener, persistent });\r\n    }\r\n\r\n    // Will clear all listeners that are used during the open state.\r\n    clearListeners(clearPersistent) {\r\n        if (google) {\r\n            if (this._listeners) {\r\n                this._listeners.forEach((e) => {\r\n                    if (clearPersistent || !e.persistent) {\r\n                        google.maps.event.removeListener(e.listener);\r\n                        e.listener = null;\r\n                    }\r\n                });\r\n                this._listeners = this._listeners.filter((e) => {\r\n                    return e.listener != null;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    isOpen() {\r\n        return this._isOpen;\r\n    }\r\n\r\n    // Open the info window after attaching to a specific marker.\r\n    open() {\r\n        const result = this.activateCallback('beforeOpen');\r\n        if (result !== undefined && !result) {\r\n            return;\r\n        }\r\n        if (this._marker) {\r\n            this.setMap(this._marker.getMap());\r\n        } else if (this._map && this._position) {\r\n            this.setMap(this._map);\r\n        }\r\n    }\r\n\r\n    // Close the info window.\r\n    close() {\r\n        const result = this.activateCallback('beforeClose');\r\n        if (result !== undefined && !result) {\r\n            return;\r\n        }\r\n        this.clearListeners();\r\n        this.setMap(null);\r\n    }\r\n\r\n    // Force close the map and remove any event listeners attached to google\r\n    destroy() {\r\n        if (this.getMap()) {\r\n            this.setMap(null);\r\n        }\r\n        // Make sure to clear all persistent listeners\r\n        this.clearListeners(true);\r\n    }\r\n\r\n    setContent(content) {\r\n        this._opts.content = content;\r\n        if (this._html && this._html.content) {\r\n            setHTML(this._html.content, content);\r\n        }\r\n    }\r\n\r\n    setPosition(latLng) {\r\n        this._position = toLatLng(latLng);\r\n        if (this._isOpen && this._position) {\r\n            this.draw();\r\n            this.resize();\r\n            this.reposition();\r\n        }\r\n    }\r\n\r\n    getWrapper() {\r\n        if (this._html) {\r\n            return this._html.wrapper;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Implementation of OverlayView draw method.\r\n    draw() {\r\n        if (!this.getMap() || !this._html) {\r\n            return;\r\n        }\r\n        if (!this._marker && !this._position) {\r\n            return;\r\n        }\r\n\r\n        // 1. Assign offset\r\n        const offset = this._opts.offset;\r\n        if (offset) {\r\n            if (offset.left) {\r\n                this._html.wrapper.style.marginLeft = offset.left;\r\n            }\r\n            if (offset.top) {\r\n                this._html.wrapper.style.marginTop = offset.top;\r\n            }\r\n        }\r\n        // 2. Set the background color\r\n        const bg = this._opts.backgroundColor;\r\n        if (bg) {\r\n            this._html.contentWrapper.style.backgroundColor = bg;\r\n            if (this._opts.pointer) {\r\n                this._html.pointerBg.style[`border${capitalizePlacement(this._opts.placement)}Color`] = bg;\r\n            }\r\n        }\r\n        // 3. Padding\r\n        if (this._opts.padding) {\r\n            this._html.contentWrapper.style.padding = this._opts.padding;\r\n            if (this._opts.shadow) {\r\n                this._html.shadowFrame.style.padding = this._opts.padding;\r\n            }\r\n        }\r\n        // 4. Border radius\r\n        if (this._opts.borderRadius) {\r\n            this._html.contentWrapper.style.borderRadius = this._opts.borderRadius;\r\n            if (this._opts.shadow) {\r\n                this._html.shadowFrame.style.borderRadius = this._opts.borderRadius;\r\n            }\r\n        }\r\n        // 5. Font Size\r\n        if (this._opts.fontSize) {\r\n            this._html.wrapper.style.fontSize = this._opts.fontSize;\r\n        }\r\n        // 6. Font Color\r\n        if (this._opts.fontColor) {\r\n            this._html.contentWrapper.style.color = this._opts.fontColor;\r\n        }\r\n        // 7. Pointer\r\n        // Check if the pointer is enabled. Also make sure the value isn't just the boolean true.\r\n        if (this._opts.pointer && this._opts.pointer !== true) {\r\n            if (this._opts.shadow) {\r\n                this._html.shadowPointer.style.width = this._opts.pointer;\r\n                this._html.shadowPointer.style.height = this._opts.pointer;\r\n            }\r\n            if (this._html.pointerBorder) {\r\n                this._html.pointerBorder.style.borderWidth = this._opts.pointer;\r\n            }\r\n            this._html.pointerBg.style.borderWidth = this._opts.pointer;\r\n        }\r\n\r\n        // 8. Border\r\n        if (this._opts.border) {\r\n            // Calculate the border width\r\n            let bWidth = 0;\r\n            if (this._opts.border.width !== undefined) {\r\n                bWidth = parseAttribute(this._opts.border.width, '0px');\r\n                this._html.contentWrapper.style.borderWidth = bWidth.value + bWidth.units;\r\n            }\r\n            bWidth = Math.round((this._html.contentWrapper.offsetWidth -\r\n                     this._html.contentWrapper.clientWidth) / 2.0);\r\n            bWidth = parseAttribute(`${bWidth}px`, '0px');\r\n\r\n            if (this._opts.pointer) {\r\n                // Calculate the pointer length\r\n                let pLength = Math.min(this._html.pointerBorder.offsetHeight,\r\n                                       this._html.pointerBorder.offsetWidth);\r\n                pLength = parseAttribute(`${pLength}px`, '0px');\r\n\r\n                let triangleDiff = Math.round(bWidth.value * (_root2 - 1));\r\n                triangleDiff = Math.min(triangleDiff, pLength.value);\r\n\r\n                this._html.pointerBg.style.borderWidth =\r\n                    (pLength.value - triangleDiff) + pLength.units;\r\n\r\n                const reverseP = capitalizePlacement(oppositePlacement(this._opts.placement));\r\n                this._html.pointerBg.style[`margin${reverseP}`] =\r\n                    triangleDiff + bWidth.units;\r\n                this._html.pointerBg.style[this._opts.placement] =\r\n                    -bWidth.value + bWidth.units;\r\n            }\r\n            const color = this._opts.border.color;\r\n            if (color) {\r\n                this._html.contentWrapper.style.borderColor = color;\r\n                if (this._html.pointerBorder) {\r\n                    this._html.pointerBorder.style[`border${capitalizePlacement(this._opts.placement)}Color`] = color;\r\n                }\r\n            }\r\n        }\r\n        // 9. Shadow\r\n        if (this._opts.shadow) {\r\n            // Check if any of the shadow settings have actually been set\r\n            const shadow = this._opts.shadow;\r\n            const isSet = (attribute) => {\r\n                const v = shadow[attribute];\r\n                return v !== undefined && v != null;\r\n            };\r\n\r\n            if (isSet('h') || isSet('v') || isSet('blur') || isSet('spread') || isSet('color')) {\r\n                const hOffset = parseAttribute(shadow.h, _defaultShadow.h);\r\n                const vOffset = parseAttribute(shadow.v, _defaultShadow.v);\r\n                const blur = parseAttribute(shadow.blur, _defaultShadow.blur);\r\n                const spread = parseAttribute(shadow.spread, _defaultShadow.spread);\r\n                const color = shadow.color || _defaultShadow.color;\r\n                const formatBoxShadow = (h, v) => {\r\n                    return `${h} ${v} ${blur.original} ${spread.original} ${color}`;\r\n                };\r\n\r\n                this._html.shadowFrame.style.boxShadow =\r\n                    formatBoxShadow(hOffset.original, vOffset.original);\r\n\r\n                // Correctly rotate the shadows before the css transform\r\n                const hRotated = (_inverseRoot2 * (hOffset.value - vOffset.value)) + hOffset.units;\r\n                const vRotated = (_inverseRoot2 * (hOffset.value + vOffset.value)) + vOffset.units;\r\n                this._html.shadowPointerInner.style.boxShadow = formatBoxShadow(hRotated, vRotated);\r\n            }\r\n            if (this._opts.shadow.opacity) {\r\n                this._html.shadowWrapper.style.opacity = this._opts.shadow.opacity;\r\n            }\r\n        }\r\n\r\n        const divPixel = this.getProjection()\r\n            .fromLatLngToDivPixel(this._position || this._marker.position);\r\n        if (divPixel) {\r\n            this._html.floatWrapper.style.top = `${Math.floor(divPixel.y)}px`;\r\n            this._html.floatWrapper.style.left = `${Math.floor(divPixel.x)}px`;\r\n        }\r\n        if (!this._isOpen) {\r\n            this._isOpen = true;\r\n            this.resize();\r\n            this.reposition();\r\n            this.activateCallback('afterOpen');\r\n            if (google) {\r\n                google.maps.event.trigger(this.getMap(), `${_eventPrefix}opened`, this);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Implementation of OverlayView onAdd method.\r\n    onAdd() {\r\n        if (this._html) {\r\n            return;\r\n        }\r\n        // Used for creating new elements\r\n        const applyCss = (element, args) => {\r\n            if (element && args) {\r\n                for (let i = 0; i < args.length; i++) {\r\n                    const className = args[i];\r\n                    if (className) {\r\n                        if (element.className) {\r\n                            element.className += ' ';\r\n                        }\r\n                        element.className += _classPrefix + className;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        const newElement = (...args) => {\r\n            const element = document.createElement('div');\r\n            applyCss(element, args);\r\n            return element;\r\n        };\r\n\r\n        this._html = {};\r\n\r\n        // 1. Create the wrapper\r\n        this._html.wrapper = newElement(\r\n            `wrapper-${this._opts.placement}`\r\n        );\r\n        if (this._opts.wrapperClass) {\r\n            this._html.wrapper.className += ` ${this._opts.wrapperClass}`;\r\n        }\r\n        if (this._opts.border) {\r\n            applyCss(this._html.wrapper, ['has-border']);\r\n        }\r\n\r\n        // 2. Create the shadow\r\n        if (this._opts.shadow) {\r\n            this._html.shadowWrapper = newElement(\r\n                `shadow-wrapper-${this._opts.placement}`\r\n            );\r\n            this._html.shadowFrame = newElement(\r\n                'frame',\r\n                'shadow-frame'\r\n            );\r\n            this._html.shadowWrapper.appendChild(this._html.shadowFrame);\r\n\r\n            if (this._opts.pointer) {\r\n                this._html.shadowPointer = newElement(\r\n                    `shadow-pointer-${this._opts.placement}`\r\n                );\r\n                this._html.shadowPointerInner = newElement(\r\n                    `shadow-inner-pointer-${this._opts.placement}`\r\n                );\r\n                this._html.shadowPointer.appendChild(this._html.shadowPointerInner);\r\n                this._html.shadowWrapper.appendChild(this._html.shadowPointer);\r\n            }\r\n\r\n            this._html.wrapper.appendChild(this._html.shadowWrapper);\r\n        }\r\n\r\n        // 3. Create the content\r\n        this._html.contentWrapper = newElement(\r\n            'frame',\r\n            'content-wrapper'\r\n        );\r\n        this._html.content = newElement(\r\n            'content'\r\n        );\r\n        if (this._opts.content) {\r\n            setHTML(this._html.content, this._opts.content);\r\n        }\r\n\r\n        // 4. Create the close button\r\n        if (this._opts.showCloseButton) {\r\n            if (this._opts.closeButtonMarkup) {\r\n                const d = document.createElement('div');\r\n                setHTML(d, this._opts.closeButtonMarkup);\r\n                this._html.closeButton = d.firstChild;\r\n            } else {\r\n                this._html.closeButton = document.createElement('button');\r\n                this._html.closeButton.setAttribute('type', 'button');\r\n                this._html.closeButton.innerHTML = '&#215;';\r\n                applyCss(this._html.closeButton, ['close-button']);\r\n            }\r\n            this._html.contentWrapper.appendChild(this._html.closeButton);\r\n        }\r\n        this._html.contentWrapper.appendChild(this._html.content);\r\n        this._html.wrapper.appendChild(this._html.contentWrapper);\r\n\r\n        // 5. Create the pointer\r\n        if (this._opts.pointer) {\r\n            if (this._opts.border) {\r\n                this._html.pointerBorder = newElement(\r\n                    `pointer-${this._opts.placement}`,\r\n                    `pointer-border-${this._opts.placement}`\r\n                );\r\n                this._html.wrapper.appendChild(this._html.pointerBorder);\r\n            }\r\n            this._html.pointerBg = newElement(\r\n                `pointer-${this._opts.placement}`,\r\n                `pointer-bg-${this._opts.placement}`\r\n            );\r\n            this._html.wrapper.appendChild(this._html.pointerBg);\r\n        }\r\n\r\n        // Create an outer wrapper\r\n        this._html.floatWrapper = newElement(\r\n            'float-wrapper'\r\n        );\r\n        this._html.floatWrapper.appendChild(this._html.wrapper);\r\n\r\n        // Add the wrapper to the Google Maps float pane\r\n        this.getPanes().floatPane.appendChild(this._html.floatWrapper);\r\n\r\n        // Now add all the event listeners\r\n        const map = this.getMap();\r\n        this.clearListeners();\r\n        if (this._opts.closeOnMapClick) {\r\n            this.trackListener(google.maps.event.addListener(map, 'click', () => {\r\n                this.close();\r\n            }));\r\n        }\r\n        if (this._opts.closeWhenOthersOpen) {\r\n            this.trackListener(google.maps.event.addListener(map, `${_eventPrefix}opened`, (other) => {\r\n                if (this !== other) {\r\n                    this.close();\r\n                }\r\n            }));\r\n        }\r\n        if (google) {\r\n            // Clear out the previous map bounds\r\n            this._previousWidth = null;\r\n            this._previousHeight = null;\r\n            this.trackListener(google.maps.event.addListener(map, 'bounds_changed', () => {\r\n                const d = map.getDiv();\r\n                const ow = d.offsetWidth;\r\n                const oh = d.offsetHeight;\r\n                const pw = this._previousWidth;\r\n                const ph = this._previousHeight;\r\n                if (pw === null || ph === null || pw !== ow || ph !== oh) {\r\n                    this._previousWidth = ow;\r\n                    this._previousHeight = oh;\r\n                    this.resize();\r\n                }\r\n            }));\r\n\r\n            // Marker moves\r\n            if (this._marker) {\r\n                this.trackListener(google.maps.event.addListener(this._marker,\r\n                    'position_changed', () => {\r\n                        this.draw();\r\n                    }));\r\n            }\r\n\r\n            // Close button\r\n            if (this._opts.showCloseButton && !this._opts.closeButtonMarkup) {\r\n                this.trackListener(google.maps.event.addDomListener(this._html.closeButton,\r\n                    'click', (e) => {\r\n                        e.cancelBubble = true;\r\n                        if (e.stopPropagation) {\r\n                            e.stopPropagation();\r\n                        }\r\n                        this.close();\r\n                    }));\r\n            }\r\n\r\n            // Stop the mouse event propagation\r\n            const mouseEvents = ['click', 'dblclick', 'rightclick', 'contextmenu',\r\n                'drag', 'dragend', 'dragstart',\r\n                'mousedown', 'mouseout', 'mouseover', 'mouseup',\r\n                'touchstart', 'touchend', 'touchmove',\r\n                'wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];\r\n            mouseEvents.forEach((event) => {\r\n                this.trackListener(google.maps.event.addDomListener(this._html.wrapper,\r\n                    event, (e) => {\r\n                        e.cancelBubble = true;\r\n                        if (e.stopPropagation) {\r\n                            e.stopPropagation();\r\n                        }\r\n                    }));\r\n            });\r\n        }\r\n\r\n\r\n        this.activateCallback('open');\r\n    }\r\n\r\n    // Implementation of OverlayView onRemove method\r\n    onRemove() {\r\n        this.activateCallback('close');\r\n        if (this._html) {\r\n            const parent = this._html.floatWrapper.parentElement;\r\n            if (parent) {\r\n                parent.removeChild(this._html.floatWrapper);\r\n            }\r\n            this._html = null;\r\n        }\r\n        this._isOpen = false;\r\n        this.activateCallback('afterClose');\r\n    }\r\n\r\n    // The map inner bounds used for panning and resizing\r\n    getMapInnerBounds() {\r\n        const mb = this.getMap().getDiv().getBoundingClientRect();\r\n        const mib = {\r\n            top: mb.top + this._opts.edgeOffset.top,\r\n            right: mb.right - this._opts.edgeOffset.right,\r\n            bottom: mb.bottom - this._opts.edgeOffset.bottom,\r\n            left: mb.left + this._opts.edgeOffset.left\r\n        };\r\n        mib.width = mib.right - mib.left;\r\n        mib.height = mib.bottom - mib.top;\r\n        return mib;\r\n    }\r\n\r\n    // Pan the Google Map such that the info window is visible\r\n    reposition() {\r\n        if (!this._opts.panOnOpen || !this._html) {\r\n            return;\r\n        }\r\n        const mib = this.getMapInnerBounds();\r\n        const wb = this._html.wrapper.getBoundingClientRect();\r\n        let dx = 0;\r\n        let dy = 0;\r\n        if (mib.left >= wb.left) {\r\n            dx = wb.left - mib.left;\r\n        } else if (mib.right <= wb.right) {\r\n            dx = wb.left - (mib.right - wb.width);\r\n        }\r\n        if (mib.top >= wb.top) {\r\n            dy = wb.top - mib.top;\r\n        } else if (mib.bottom <= wb.bottom) {\r\n            dy = wb.top - (mib.bottom - wb.height);\r\n        }\r\n        if (dx !== 0 || dy !== 0) {\r\n            this.getMap().panBy(dx, dy);\r\n        }\r\n    }\r\n\r\n    // Resize the info window to fit within the map bounds and edge offset\r\n    resize() {\r\n        if (!this._html) {\r\n            return;\r\n        }\r\n        const mib = this.getMapInnerBounds();\r\n        // Handle the max width\r\n        let maxWidth = mib.width;\r\n        if (this._opts.maxWidth !== undefined) {\r\n            maxWidth = Math.min(maxWidth, this._opts.maxWidth);\r\n        }\r\n        maxWidth -= (this._html.wrapper.offsetWidth - this._html.content.offsetWidth);\r\n        this._html.content.style.maxWidth = `${maxWidth}px`;\r\n\r\n        // Handle the max height\r\n        let maxHeight = mib.height;\r\n        if (this._opts.maxHeight !== undefined) {\r\n            maxHeight = Math.min(maxHeight, this._opts.maxHeight);\r\n        }\r\n        maxHeight -= (this._html.wrapper.offsetHeight - this._html.content.offsetHeight);\r\n        this._html.content.style.maxHeight = `${maxHeight}px`;\r\n    }\r\n}\r\n"]}